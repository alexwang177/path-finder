{"version":3,"sources":["ControlBar/ControlBar.js","Board/Point.js","Board/Node.js","EventHandlers/Node/nodeHandlers.js","Constants/constants.js","Board/Board.js","EventHandlers/App/appHandlers.js","Algorithms/algorithms.js","Algorithms/mazeAlgorithms.js","App.js","GridFunctions/gridfunctions.js","Visualize/visualize.js","serviceWorker.js","index.js"],"names":["ControlBar","props","className","id","name","value","maze","onChange","handleFormChange","onClick","generateMaze","algorithm","visualize","toUpperCase","speed","selected","placeholder","type","rowInput","colInput","handleFormButton","Point","draggable","onDragStart","dragStart","onDragOver","e","stopPropagation","Node","handleMouseEnter","marker","target","classList","add","location","split","handleMouseLeave","remove","handleClick","console","log","nodeValue","handleNodeClick","nodeDisplay","state","loading","dragOver","preventDefault","nextProps","this","onMouseEnter","onMouseLeave","onDrop","drop","React","Component","Board","grid","displayGrid","numRows","numCols","map","row","rowIndex","displayRow","item","colIndex","key","mazeIsGenerating","onMouseDown","handleMouseDown","onMouseUp","handleMouseUp","clearGrid","app","setState","prevState","createGrid","bdsHelper","queue","visitedSelf","visitedOther","startRow","startCol","endRow","endCol","totalDelay","delayOffset","parentMap","length","loc","shift","col","setTimeout","newGrid","slice","dR","dC","i","newR","newC","hasOwnProperty","set","getPathBDS","push","meetingRow","meetingCol","cur","pathA","pathAContainsStart","has","get","pathB","finalPath","reverse","concat","forEach","rowIdx","colIdx","getPath","path","getSpeed","divide","x","y","width","height","orientation","a","wx","wy","horizontal","getRandomInt","px","py","dx","dy","updateState","nx","ny","w","h","chooseOrientation","min","max","Math","ceil","floor","random","mazeDimensions","orgWidth","orgHeight","newWidth","Number","newHeight","j","mazeBorder","App","initGrid","offset","round","clearVisited","element","isNaN","alert","mouseIsDown","dfs","visited","stack","Map","pop","bfs","bidirectional","queueA","queueB","visitedA","visitedB","dataTransfer","setData","style","display","pointID","getData","point","document","getElementById","pointRow","pointCol","pointValue","componentDidMount","window","addEventListener","updateGrid","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9d33a56b.chunk.js","sourcesContent":["import React from 'react'\n\nfunction ControlBar(props) {\n    return(\n        <header className=\"control-bar\">\n\n            <div>\n                <h1>PathFinding</h1>\n                <h1>Visualizer</h1>\n            </div>\n\n            <div className=\"select-container\">\n                <label className=\"select-label\">Maze Type</label>\n                <div className=\"select control-bar-selectors\" id=\"maze-selector\">\n                    <select name=\"maze\" value={props.maze} onChange={props.handleFormChange}> \n                        <option value=\"rmd\">Recursive Maze Division</option>\n                        <option value=\"rmd-vs\">Vertical Skew</option>\n                        <option value=\"rmd-hs\">Horizontal Skew</option>\n                    </select>\n                </div>\n            </div>\n    \n            <button className=\"button\" id=\"maze-button\" onClick={props.generateMaze}>Generate Maze</button>\n\n            <div className=\"select-container\">\n            <label className=\"select-label\">Algorithm</label>\n                <div className=\"select control-bar-selectors\" id=\"algo-selector\">\n                    <select name=\"algorithm\" value={props.algorithm} onChange={props.handleFormChange}> \n                        <option value=\"dfs\">Depth-First Search</option>\n                        <option value=\"bfs\">Breadth-First Search</option>\n                        <option value=\"dijkstra\">Dijkstra</option>\n                        <option value=\"bds\">Bi-Directional Search</option>\n                    </select>\n                </div> \n            </div>\n\n            <button className=\"button\" id=\"visualize-button\" onClick={props.visualize}>Visualize {props.algorithm.toUpperCase()}</button>\n\n            {/*<div className=\"control-bar-selectors\" id=\"mark-selector\">\n                <select name=\"marker\" value={props.marker} onChange={props.handleFormChange}> \n                    <option value=\"start\">Start</option>\n                    <option value=\"end\">End</option>\n                    <option value=\"wall\">Wall</option>\n                </select>\n            </div>*/}\n\n            <div className=\"select-container\">\n                <label className=\"select-label\">Speed</label>\n                <div className=\"select control-bar-selectors\" id=\"speed-selector\">\n                    <select name=\"speed\" value={props.speed} onChange={props.handleFormChange}> \n                        <option value=\"slow\">Slow</option>\n                        <option selected=\"selected\" value=\"moderate\">Moderate</option>\n                        <option value=\"fast\">Fast</option>\n                    </select>\n                </div> \n            </div>\n    \n\n            <div>\n                <div className=\"control-bar-selectors\" id=\"grid-selector\">\n                        <input placeholder=\"# Rows\" className=\"effect-1\" type=\"text\" name=\"rowInput\" value={props.rowInput} onChange={props.handleFormChange}/>\n                        <span className=\"focus-border\"></span>\n                </div>\n\n                <div className=\"control-bar-selectors\" id=\"grid-selector\">\n                        <input placeholder=\"# Columns\" className=\"effect-1\" type=\"text\" name=\"colInput\" value={props.colInput} onChange={props.handleFormChange}/>\n                        <span className=\"focus-border\"></span>\n                </div>\n            </div>\n\n            <div className=\"control-bar-selectors\" id=\"grid-selector\">\n                <button className=\"button\" name=\"sizeButton\" onClick={props.handleFormButton}>Update Grid Size</button>\n            </div>\n\n            <div className=\"control-bar-selectors\" id=\"grid-selector\">\n                <button className=\"button\" name=\"clearButton\" onClick={props.handleFormButton}>Clear Grid</button>\n            </div>\n\n        </header>\n    )\n}\n\nexport default ControlBar","import React from 'react'\n\nfunction Point(props) {\n\n    /*const dragStart = (e) => {\n        const target = e.target\n\n        e.dataTransfer.setData(\"pointID\", target.id)\n\n        setTimeout(() => {\n            target.style.display = \"none\"\n        }, 0)\n\n        setTimeout(() => {\n            target.style.display = \"block\"\n        }, 0)\n    }*/\n\n    const dragOver = (e) => {\n        e.stopPropagation()\n    }\n\n    return (\n        <div\n            id={props.id}\n            draggable={true}\n            onDragStart={props.dragStart}\n            onDragOver={dragOver}\n        >\n        </div>\n    )\n}\n\nexport default Point","import React from 'react'\nimport { START, END, WALL, VISITED, EMPTY, PATH } from '../Constants/constants'\n\nimport { handleClick, handleMouseEnter, handleMouseLeave } from '../EventHandlers/Node/nodeHandlers' \nimport { exportDefaultSpecifier } from '@babel/types'\n\nimport Point from './Point'\n\nclass Node extends React.Component {\n\n    constructor() {\n        super()\n        this.state = {\n            loading: false\n        }\n    }\n\n    shouldComponentUpdate(nextProps) {\n        if(nextProps.nodeValue != this.props.nodeValue) {\n            return true\n        }\n\n        return false\n    }\n\n    handleMouseEnter = (e) => handleMouseEnter(e, this.props)\n\n    handleMouseLeave = (e) => handleMouseLeave(e, this.props)\n\n    handleClick = () => handleClick(this.props)\n    \n    nodeDisplay = () => {\n        let className = \"node-div\"\n\n        if(!this.state.loading) {\n            if(this.props.nodeValue === START){\n                className += \" start-node\"\n            }\n            else if(this.props.nodeValue === END){\n                className += \" end-node\"\n            }\n            else if(this.props.nodeValue === WALL){\n                className += \" wall-node\"\n            }\n            else if(this.props.nodeValue === VISITED){\n                className += \" visited-node\"\n            }\n            else if(this.props.nodeValue === PATH){\n                className += \" path-node\"\n            }\n        }\n\n        return className\n    }\n\n    /*drop = (e) => {\n        e.preventDefault()\n        const pointID = e.dataTransfer.getData(\"pointID\")\n\n        const point = document.getElementById(pointID)\n        point.style.display = \"block\"\n\n        e.target.appendChild(point)\n    }*/\n\n    dragOver = (e) => {\n        e.preventDefault()\n    }\n\n    render() {\n\n        const location = this.props.location.split(\" \")\n        //console.log(\"node render \" + location[0] + \" \" + location[1])\n        //console.log(this.props.nodeValue)\n\n        const className = this.nodeDisplay()\n\n        return(\n            <div\n                id={this.props.location}\n                className={className} \n                onMouseEnter={this.handleMouseEnter} \n                onMouseLeave={this.handleMouseLeave}\n                onClick={this.handleClick}\n                onDrop={this.props.drop}\n                onDragOver={this.dragOver}\n            >\n                {this.props.nodeValue === START ? <Point id=\"start-point\" dragStart={this.props.dragStart}/> : null}\n                {this.props.nodeValue === END ? <Point id=\"end-point\" dragStart={this.props.dragStart}/> : null}\n            </div>\n        )\n    }\n}\n\nexport default Node","import { WALL } from \"../../Constants/constants\"\n\nexport const handleClick = (props) => {\n    const location = props.location.split(\" \")\n\n    console.log(location)\n    console.log(props.nodeValue)\n\n    props.handleNodeClick(location[0], location[1])\n}\n\nexport const handleMouseEnter = (e, props) => {\n\n    if(props.marker === \"wall\")\n        e.target.classList.add(props.marker + \"-hover\")\n\n    const location = props.location.split(\" \")\n\n    //console.log(location)\n    //console.log(this.props.nodeValue)\n\n    props.handleMouseEnter(location[0], location[1])\n}\n\nexport const handleMouseLeave = (e, props) => {\n    /*this.setState({\n        isHover: false\n    })*/\n    if(props.marker === \"wall\")\n        e.target.classList.remove(props.marker + \"-hover\")\n}\n\nexport const updateNode = (row, col, value) => {\n    const node = document.getElementById(row + \" \" + col)\n\n    switch(value) {\n        case WALL:\n            node.classList.add(\"wall-node\")\n            break\n        default: \n            break\n    }\n}","export const EMPTY = 0\nexport const START = 1\nexport const END = 2\nexport const WALL = 3\nexport const PATH = 4\nexport const VISITED = -1\n\nexport const SLOW = 150\nexport const MODERATE = 75\nexport const FAST = 25\n\nexport const HORIZONTAL = 1\nexport const VERTICAL = 2\nexport const SOUTH = 3\nexport const EAST = 4","import React from 'react'\nimport Node from './Node'\n\nfunction Board(props) {\n\n    const grid = props.grid\n    const numRows = props.numRows\n    const numCols = props.numCols\n\n    const displayGrid = grid.map((row, rowIndex) => {\n\n        const displayRow = row.map((item, colIndex) => {\n            return (<Node \n                        key={rowIndex + \" \" + colIndex} \n                        location={rowIndex + \" \" + colIndex} \n                        marker={props.marker}\n                        nodeValue={props.grid[rowIndex][colIndex]}\n                        handleNodeClick={props.handleNodeClick}\n                        handleMouseEnter={props.handleMouseEnter}\n                        mazeIsGenerating={props.mazeIsGenerating}\n                        drop={props.drop}\n                        dragStart={props.dragStart}\n                        />)\n        })\n\n        return (\n            <div \n                key={rowIndex} \n                className=\"grid-row\"\n            >\n                {displayRow}\n            </div>\n        )\n    })\n\n    return(\n        <div className=\"board-container\">\n            <div className=\"board\" \n                 onMouseDown={props.handleMouseDown} \n                 onMouseUp={props.handleMouseUp}\n            >   \n                {displayGrid}\n            </div>\n        </div>\n    )\n}\n\nexport default Board\n","import { START, END, WALL, VISITED, EMPTY } from '../../Constants/constants'\n\nexport const handleMouseDown = (app) => {\n    app.setState({ mouseIsDown: true })\n}\n\nexport const handleMouseUp = (app) => {\n    app.setState({ mouseIsDown: false })\n}\n\nexport const handleMouseEnter = (rowIndex, colIndex, app) => {\n    if(!app.state.mouseIsDown) return\n\n    if(app.state.grid[rowIndex][colIndex] === START || app.state.grid[rowIndex][colIndex] === END) return\n\n    app.setState((prevState) => {\n      const newGrid = prevState.grid.map((row) => row.slice())\n\n      if(prevState.marker === \"wall\") {\n\n        newGrid[rowIndex][colIndex] === WALL ? \n          newGrid[rowIndex][colIndex] = EMPTY :\n          newGrid[rowIndex][colIndex] = WALL\n      }\n\n      return {\n        grid: newGrid\n      }\n    })\n}\n\nexport const handleNodeClick = (rowIndex, colIndex, app) => {\n  if(app.state.grid[rowIndex][colIndex] === START || app.state.grid[rowIndex][colIndex] === END) return\n\n    app.setState((prevState) => {\n      const newGrid = prevState.grid.map((row) => row.slice())\n\n      if(prevState.marker === \"wall\") {\n\n        newGrid[rowIndex][colIndex] === WALL ? \n          newGrid[rowIndex][colIndex] = EMPTY :\n          newGrid[rowIndex][colIndex] = WALL\n      }\n\n      return {\n        grid: newGrid\n      }\n    })\n}\n\nexport const handleFormButton = (e, app) => {\n    const {name} = e.target\n\n    if(name === \"sizeButton\") {\n\n      if(isNaN(app.state.rowInput) || isNaN(app.state.colInput) || app.state.rowInput === \"\" || app.state.colInput === \"\"){\n        alert(\"Please enter a valid input.\")\n        return\n      } \n\n      app.setState((prevState) => {\n\n        return {\n          numRows: Number(prevState.rowInput),\n          numCols: Number(prevState.colInput),\n          grid: app.createGrid(prevState.rowInput, prevState.colInput),\n          rowInput: \"\",\n          colInput: \"\"\n        }\n      })\n    }\n\n    if(name === \"clearButton\") {\n      clearGrid(app)\n    }\n}\n\nconst clearGrid = (app) => {\n  //console.log(\"clear grid\")\n\n  app.setState((prevState) => {\n\n      return {\n        grid: app.createGrid(prevState.numRows, prevState.numCols)\n      }\n    })\n}\n\n\nexport const handleFormChange = (e, app) => {\n\n    const {name, value} = e.target\n\n    if(name === \"rowInput\" || name === \"colInput\" || name === \"algorithm\" || name === \"marker\" || name === \"speed\" || name === \"maze\") {\n      app.setState({ [name] : value })\n    }\n  }\n","import { START, END, WALL, VISITED, EMPTY, PATH, SLOW, MODERATE, FAST } from '../Constants/constants'\n\nexport const dfs = (startRow, startCol, endRow, endCol, visited, app) => {\n    let stack = []\n    stack.push([startRow, startCol])\n\n    let parentMap = new Map()\n\n    let found = false\n\n    let totalDelay = 0\n    const delayOffset = getSpeed(app.state.speed)\n\n    while(stack.length !== 0) {\n\n      const loc = stack.pop()\n      const row = loc[0]\n      const col = loc[1]\n\n      if(row < 0 || col < 0 || row >= app.state.numRows || col >= app.state.numCols) continue\n\n      if(visited[row][col]) continue\n\n      if(app.state.grid[row][col] === WALL) continue\n\n      //console.log(\"visiting node...\")\n      visited[row][col] = true;\n\n      if(row === endRow && col === endCol) {\n          found = true\n          break\n      }\n\n      if(row !== startRow || col !== startCol) {\n        // set node to visited\n        setTimeout(() => app.setState((prevState) => {\n          const newGrid = prevState.grid.map((row) => row.slice())\n          newGrid[row][col] = VISITED\n\n          return {\n            grid: newGrid\n          }\n        }), totalDelay)\n\n        totalDelay += delayOffset\n      }\n\n        //console.log(app.state.grid)\n\n        const dR = [-1, 0, 1, 0]\n        const dC = [0, 1, 0, -1]\n\n        for(let i = 0; i < 4; i++) {\n            const newR = row + dR[i]\n            const newC = col + dC[i]\n\n            if(newR < 0 || newC < 0 || newR >= app.state.numRows || newC >= app.state.numCols) continue\n\n            if(!visited[newR][newC]) {\n                stack.push([row + dR[i], col + dC[i]])\n                parentMap.set(newR + \" \" + newC, row + \" \" + col)\n            }\n        }\n\n    \n    }\n    getPath(parentMap, endRow, endCol, totalDelay, delayOffset, app)\n\n  }\n\n  export const bfs = (startRow, startCol, endRow, endCol, visited, app) => {\n    let queue = []\n    queue.push([startRow, startCol])\n\n    let parentMap = new Map()\n    let found = false\n\n    let totalDelay = 0\n    const delayOffset = getSpeed(app.state.speed)\n\n    while(queue.length !== 0) {\n      const loc = queue.shift()\n      const row = loc[0]\n      const col = loc[1]\n\n      if(row < 0 || col < 0 || row >= app.state.numRows || col >= app.state.numCols) continue\n\n      if(visited[row][col]) continue\n\n      if(app.state.grid[row][col] === WALL) continue\n\n      //console.log(\"bfs visiting node...\")\n      visited[row][col] = true;\n\n      if(row === endRow && col === endCol) {\n          found = true\n          break\n      }\n\n      if(row !== startRow || col !== startCol) {\n        // set node to visited\n        setTimeout(() => app.setState((prevState) => {\n          const newGrid = prevState.grid.map((row) => row.slice())\n          newGrid[row][col] = VISITED\n\n          return {\n            grid: newGrid\n          }\n        }), totalDelay)\n\n        totalDelay += delayOffset\n      }\n\n      const dR = [-1, 0, 1, 0]\n      const dC = [0, 1, 0, -1]\n\n      for(let i = 0; i < 4; i++) {\n        const newR = row + dR[i]\n        const newC = col + dC[i]\n\n        if(newR < 0 || newC < 0 || newR >= app.state.numRows || newC >= app.state.numCols) continue\n\n        if(!visited[newR][newC]){\n            queue.push([newR, newC])\n            parentMap.set(newR + \" \" + newC, row + \" \" + col)\n        }\n\n      }\n\n    }\n    // while loop exits\n\n    getPath(parentMap, endRow, endCol, totalDelay, delayOffset, app)\n  }\n\n  export const bidirectional = (startRow, startCol, endRow, endCol, visited, app) => {\n    //console.log(\"bds\")\n    let queueA = []\n    let queueB = []\n\n    let visitedA = {}\n    let visitedB = {}\n\n    visitedA[startRow + \" \" + startCol] = \"#\"\n    visitedB[endRow + \" \" + endCol] = \"#\"\n\n    queueA.push([startRow, startCol])\n    queueB.push([endRow, endCol])\n\n    //console.log(\"start: \" + startRow + \" \" + startCol)\n\n    let totalDelay = [0]\n    const delayOffset = getSpeed(app.state.speed)\n\n    let found = false\n\n    let parentMap = new Map()\n\n    while(queueA.length !== 0 && queueB.length !== 0) {\n      if(bdsHelper(queueA, visitedA, visitedB, startRow, startCol, endRow, endCol, totalDelay, delayOffset, parentMap, app)){\n        found = true\n        break\n      }\n\n      if(bdsHelper(queueB, visitedB, visitedA, startRow, startCol, endRow, endCol, totalDelay, delayOffset, parentMap, app)){\n        found = true\n        break\n      }\n    }\n\n    //if(found) {\n      //getPathBDS(parentMap, endRow, endCol, totalDelay[0], delayOffset, app)\n    //}\n  }\n\n  const bdsHelper = (queue, visitedSelf, visitedOther, startRow, startCol, endRow, endCol, totalDelay, delayOffset, parentMap, app) => {\n    if(queue.length !== 0) {\n      //console.log(\"bds helper\")\n      const loc = queue.shift()\n      const row = loc[0]\n      const col = loc[1]\n\n      //console.log(row + \" \" + col)\n\n      if(row < 0 || col < 0 || row >= app.state.numRows || col >= app.state.numCols) return false\n\n      if(app.state.grid[row][col] === WALL) return false\n\n      // mark current node as visited\n      const startMark = row === startRow && col === startCol\n      const endMark = row === endRow && col === endCol\n\n      if(!startMark && !endMark) {\n        // set node to visited\n        setTimeout(() => app.setState((prevState) => {\n          const newGrid = prevState.grid.map((row) => row.slice())\n          newGrid[row][col] = VISITED\n\n          return {\n            grid: newGrid\n          }\n        }), totalDelay[0])\n\n        totalDelay[0] += delayOffset\n      }\n\n      const dR = [-1, 0, 1, 0]\n      const dC = [0, 1, 0, -1]\n\n      for(let i = 0; i < 4; i++) {\n        const newR = row + dR[i]\n        const newC = col + dC[i]\n\n        if(visitedOther.hasOwnProperty(newR + \" \" + newC)){\n          //console.log(\"Meeting: \" + newR + \" \" + newC)\n\n          parentMap.set(newR + \" \" + newC + \"alt\", row + \" \" + col)\n\n          setTimeout(() => app.setState((prevState) => {\n            const newGrid = prevState.grid.map((row) => row.slice())\n            newGrid[newR][newC] = VISITED\n  \n            return {\n              grid: newGrid\n            }\n          }), totalDelay[0])\n  \n          totalDelay[0] += delayOffset\n\n          getPathBDS(parentMap, newR, newC, totalDelay[0], delayOffset, app)\n\n          return true\n        }\n        else if(!visitedSelf.hasOwnProperty(newR + \" \" + newC)){\n\n          if(newR < 0 || newC < 0 || newR >= app.state.numRows || newC >= app.state.numCols) continue\n\n          if(app.state.grid[newR][newC] === WALL) continue\n\n          visitedSelf[newR + \" \" + newC] = \"#\"\n          queue.push([newR, newC])\n          parentMap.set(newR + \" \" + newC, row + \" \" + col)\n        }\n\n      }\n\n    }\n\n    return false\n  }\n\n  export const getPathBDS = (parentMap, meetingRow, meetingCol, totalDelay, delayOffset, app) => {\n    //console.log(\"PATH BDS\")\n\n    let cur = meetingRow + \" \" + meetingCol\n    let pathA = []\n\n    let pathAContainsStart = false\n\n    while(parentMap.has(cur)) {\n      const loc = cur.split(\" \")\n      const row = loc[0]\n      const col = loc[1]\n\n      if(app.state.grid[row][col] !== START && app.state.grid[row][col] !== END) \n        pathA.push([row, col])\n\n      //if(app.state.grid[row][col] === START) pathAContainsStart = true\n\n      cur = parentMap.get(cur)\n    }\n\n    const loc = cur.split(\" \")\n    if(app.state.grid[loc[0]][loc[1]] === START) pathAContainsStart = true\n\n    //pathA.reverse()\n\n    cur = meetingRow + \" \" + meetingCol + \"alt\"\n    let pathB = []\n    \n    while(parentMap.has(cur)) {\n      const loc = cur.split(\" \")\n      const row = loc[0]\n      const col = loc[1]\n\n      if(app.state.grid[row][col] !== START && app.state.grid[row][col] !== END) \n        pathB.push([row, col])\n\n      cur = parentMap.get(cur)\n    }\n\n    let finalPath = []\n\n    if(pathAContainsStart) {\n      pathA.reverse()\n      finalPath = pathA.concat(pathB)\n    }\n    else {\n      pathB.reverse()\n      finalPath = pathB.concat(pathA)\n    }\n\n    // Add some time before the path renders\n    totalDelay += 500\n\n    finalPath.forEach((loc) => {\n        const rowIdx = loc[0]\n        const colIdx = loc[1]\n\n        setTimeout(() => app.setState((prevState) => {\n            const newGrid = prevState.grid.map((row) => row.slice())\n\n            if(prevState.grid[rowIdx][colIdx] !== START && prevState.grid[rowIdx][colIdx] !== END)\n                newGrid[rowIdx][colIdx] = PATH\n\n            return {\n            grid: newGrid\n            }\n        }), totalDelay)\n\n        totalDelay += delayOffset\n    })\n  }\n\n  export const getPath = (parentMap, endRow, endCol, totalDelay, delayOffset, app) => {\n    //console.log(\"PATH\")\n\n    //console.log(parentMap)\n\n    let cur = endRow + \" \" + endCol\n    let path = []\n\n    while(parentMap.has(cur)) {\n        //console.log(cur)\n\n        const loc = cur.split(\" \")\n        const row = loc[0]\n        const col = loc[1]\n\n        if(row !== endRow || col !== endCol) \n            path.push([row, col])\n\n        cur = parentMap.get(cur)\n    }\n\n    path.reverse()\n\n    // Add some time before the path renders\n    totalDelay += 500\n\n    path.forEach((loc) => {\n        const rowIdx = loc[0]\n        const colIdx = loc[1]\n\n        setTimeout(() => app.setState((prevState) => {\n            const newGrid = prevState.grid.map((row) => row.slice())\n\n            if(prevState.grid[rowIdx][colIdx] !== END)\n                newGrid[rowIdx][colIdx] = PATH\n\n            return {\n            grid: newGrid\n            }\n        }), totalDelay)\n\n        totalDelay += delayOffset\n    })\n  }\n\n  const getSpeed = (speed) => {\n    switch(speed) {\n      case \"slow\":\n        return SLOW\n        break\n\n      case \"moderate\":\n        return MODERATE\n        break\n\n      case \"fast\":\n        return FAST\n        break\n    }\n  }","import { START, END, WALL, VISITED, EMPTY, PATH, SLOW, MODERATE, FAST, HORIZONTAL, VERTICAL, SOUTH, EAST} from '../Constants/constants'\nimport { updateNode } from '../EventHandlers/Node/nodeHandlers'\n\nexport const generateMaze = (app) => {\n    // Change grid width and height to be odd values\n    //mazeDimensions(app)\n\n    // Timing of maze generation\n    let totalDelay = [0]\n    let delayOffset = 20\n\n    mazeDimensions(app, totalDelay, delayOffset)\n\n    // Generate border of maze\n    //mazeBorder(app, totalDelay, delayOffset, () => divide(0, 0, app.state.numCols-1, app.state.numRows-1, VERTICAL, totalDelay, delayOffset, app))\n\n    // Generate rest of maze\n    // divide(0, 0, app.state.numCols, app.state.numRows, HORIZONTAL, totalDelay, delayOffset, app)\n\n    //app.setState({ mazeIsGenerating: false })\n}\n\nconst divide = async (x, y, width, height, orientation, totalDelay, delayOffset, app) => {\n    if(width <= 2 || height <= 2) return\n\n    const horizontal = orientation === HORIZONTAL\n\n    let wx = x\n    let wy = y\n\n    if(horizontal) {\n        //while(wy % 2 !== 0) \n        wy = y + getRandomInt(0, height - 1)\n\n        while(wy % 2 !== 0)\n            wy = y + getRandomInt(0, height - 1)\n    }\n    else{\n        //while(wx % 2 !== 0) \n        wx = x + getRandomInt(0, width - 1)\n\n        while(wx % 2 !== 0)\n            wx = x + getRandomInt(0, width - 1)\n    }\n\n    let px = wx\n    let py = wy\n\n    if(horizontal) {\n        while(px % 2 !== 1) \n            px = wx + getRandomInt(1, width - 1)\n    }\n    else{\n        while(py % 2 !== 1) \n            py = wy + getRandomInt(1, height - 1) \n    }\n\n    const dx = horizontal ? 1 : 0\n    const dy = horizontal ? 0 : 1\n\n    const length = horizontal ? width : height\n\n    const dir = horizontal ? SOUTH : EAST\n\n    //console.log(\"wx: \" + wx)\n    //console.log(\"wy: \" + wy)\n    //onsole.log(\"px: \" + px)\n    //console.log(\"py: \" + py)\n    //console.log(\"divide time begin: \" + totalDelay[0])\n\n    for(let i = 0; i < length; i++) {\n        if(wx !== px || wy !== py) {\n            // grid[wy][wx] = WALL\n            //console.log(wy + \" \" + wx + \" = WALL\" + \" time: \" + totalDelay[0])\n\n            setTimeout(function(wy, wx, app) {\n                return updateState(wy, wx, app)\n            }, totalDelay[0], wy, wx, app)\n\n            /*setTimeout(() => app.setState((prevState) => {\n                const newGrid = prevState.grid.map((row) => row.slice())\n\n                    newGrid[wy][wx] = WALL\n      \n                return {\n                  grid: newGrid\n                }\n              }), 0)*/\n              \n            totalDelay[0] += delayOffset\n        \n        }\n        wx += dx\n        wy += dy\n    }\n\n    let nx = x\n    let ny = y\n\n    let w = horizontal ? width : wx - x + 1\n    let h = horizontal ? wy - y + 1 : height\n\n    await divide(nx, ny, w, h, chooseOrientation(w, h, app), totalDelay, delayOffset, app)\n\n    nx = horizontal ? x : wx + 1\n    ny = horizontal ? wy + 1 : y\n    w = horizontal ? width : x + width - wx - 1\n    h = horizontal ? y + height - wy - 1 : height\n    await divide(nx, ny, w, h, chooseOrientation(w, h, app), totalDelay, delayOffset, app)\n}\n\nconst updateState = (wy, wx, app) => {\n    //console.log(app)\n\n    app.setState((prevState) => {\n\n        //console.log(prevState.grid)\n        //console.log(wy + \" \" + wx)\n        const newGrid = prevState.grid.map((row) => row.slice())\n\n        if(prevState.grid[wy][wx] !== START && prevState.grid[wy][wx] !== END)\n            newGrid[wy][wx] = WALL\n\n        return {\n          grid: newGrid\n        }\n      })\n\n    //console.log(\"hi\")\n}\n\nconst chooseOrientation = (w, h, app) => {\n    if(app.state.maze === \"rmd\") {\n        if(w < h) {\n            return HORIZONTAL;\n        } else if (h < w) {\n            return VERTICAL;\n        } else {\n            //return rand.nextInt(2) + 1;\n            return getRandomInt(0, 2) + 1\n        }\n    }\n    else if(app.state.maze === \"rmd-hs\") {\n        const num = getRandomInt(0, 10)\n\n        if(num <= 1) return VERTICAL\n    \n        return HORIZONTAL\n    }\n    else if(app.state.maze === 'rmd-vs') {\n        const num = getRandomInt(0, 10)\n\n        if(num <= 1) return HORIZONTAL\n    \n        return VERTICAL\n    }\n}\n\nconst getRandomInt = (min, max) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n\n    return Math.floor(Math.random() * (max - min)) + min\n}\n\nconst mazeBorder = (app, totalDelay, delayOffset) => {\n    //console.log(\"maze border\")\n\n    // Top Row and Bottom Row\n\n    for(let j = 0; j < app.state.numCols; j++) {\n        setTimeout(() => {\n            app.setState((prevState) => {\n            const newGrid = prevState.grid.map((row) => row.slice())\n\n            if(prevState.grid[0][j] !== START && prevState.grid[0][j] !== END)\n                newGrid[0][j] = WALL\n            if(prevState.grid[app.state.numRows - 1][j] !== START && prevState.grid[app.state.numRows - 1][j] !== END)\n                newGrid[app.state.numRows - 1][j] = WALL\n  \n            return {\n              grid: newGrid\n            }\n          })\n\n          //console.log(\"setting border\")\n        }, totalDelay[0])\n\n          totalDelay[0] += delayOffset\n  \n          //console.log(\"border: \" + totalDelay[0])\n\n    }\n\n    // Left Col and Right Col\n\n    for(let i = 0; i < app.state.numRows; i++) {\n        setTimeout(() => {app.setState((prevState) => {\n            const newGrid = prevState.grid.map((row) => row.slice())\n\n            if(prevState.grid[i][0] !== START && prevState.grid[i][0] !== END)\n                newGrid[i][0] = WALL\n            if(prevState.grid[i][app.state.numCols - 1] !== START && prevState.grid[i][app.state.numCols - 1] !== END)    \n                newGrid[i][app.state.numCols - 1] = WALL\n  \n            return {\n              grid: newGrid\n            }\n          })\n          \n          //console.log(\"setting border\")\n        }, totalDelay[0])\n\n          totalDelay[0] += delayOffset\n\n          //console.log(\"border: \" + totalDelay[0])\n    }\n\n    totalDelay[0] += delayOffset\n\n    //console.log(\"callback time: \" + totalDelay[0])\n    //setTimeout(() => callback(), totalDelay[0])\n\n    //callback()\n}\n\nconst mazeDimensions = (app, totalDelay, delayOffset) => {\n    //console.log(\"maze dimensions\")\n\n    const orgWidth = app.state.numCols\n    const orgHeight = app.state.numRows\n\n    const newWidth = orgWidth % 2 == 0 ? Number(orgWidth) + 1 : orgWidth\n    const newHeight = orgHeight % 2 == 0 ? Number(orgHeight) + 1 : orgHeight\n\n    const orientation = app.state.maze === \"rmd-hs\" ? HORIZONTAL : VERTICAL\n\n    app.setState(\n        {\n          numRows: newHeight,\n          numCols: newWidth,\n          grid: app.createGrid(newHeight, newWidth),\n          rowInput: \"\",\n          colInput: \"\",\n          mazeIsGenerating: true\n        }, \n        () => {\n            //mazeBorder(app, totalDelay, delayOffset, () => divide(0, 0, app.state.numCols-1, app.state.numRows-1, VERTICAL, totalDelay, delayOffset, app))\n            mazeBorder(app, totalDelay, delayOffset)\n            divide(0, 0, app.state.numCols-1, app.state.numRows-1, orientation, totalDelay, delayOffset, app)\n        }\n    )\n}","import React from 'react';\nimport ReactDOM from 'react-dom'\n\nimport ControlBar from './ControlBar/ControlBar'\nimport Board from './Board/Board'\n\nimport { START, END, WALL, VISITED, EMPTY } from './Constants/constants'\n\nimport { handleMouseDown, handleMouseUp, handleMouseEnter, handleNodeClick, handleFormButton, handleFormChange } from './EventHandlers/App/appHandlers'\nimport { dfs, bfs, bidirectional, getPath } from './Algorithms/algorithms'\nimport { createGrid, clearVisited } from './GridFunctions/gridfunctions'\nimport { visualize } from './Visualize/visualize'\nimport { generateMaze } from './Algorithms/mazeAlgorithms'\n\nimport './App.css'\n\nclass App extends React.Component {\n\n  constructor() {\n    super()\n\n    const initRows = 20\n    const initCols = 50\n\n    this.state = {\n      numRows: initRows,\n      numCols: initCols,\n      grid: this.createGrid(initRows, initCols),\n      algorithm: \"dfs\",\n      maze: \"rmd\",\n      marker: \"wall\",\n      speed: \"moderate\",\n      rowInput: \"\",\n      colInput: \"\",\n      mouseIsDown: false,\n      mazeIsGenerating: false\n    }\n  }\n\n  // Initialize grid functions\n\n  createGrid = (numRows, numCols) => createGrid(numRows, numCols)\n\n  clearVisited = () => clearVisited(this)\n\n  // Initialize event handlers\n\n  handleFormChange = (e) => handleFormChange(e, this)\n\n  handleFormButton = (e) => handleFormButton(e, this)\n\n  handleNodeClick = (rowIndex, colIndex) => handleNodeClick(rowIndex, colIndex, this)\n\n  handleMouseDown = () => handleMouseDown(this)\n\n  handleMouseUp = () => handleMouseUp(this)\n\n  handleMouseEnter = (rowIndex, colIndex) => handleMouseEnter(rowIndex, colIndex, this)\n\n  // Initialize algorithms\n\n  dfs = (startRow, startCol, endRow, endCol, visited) => dfs(startRow, startCol, endRow, endCol, visited, this)\n\n  bfs = (startRow, startCol, endRow, endCol, visited) => bfs(startRow, startCol, endRow, endCol, visited, this)\n\n  bidirectional = (startRow, startCol, endRow, endCol, visited) => bidirectional(startRow, startCol, endRow, endCol, visited, this)\n\n  // Initialize visualize function\n\n  visualize = () => visualize(this)\n\n  // Initialize generateMaze function\n\n  generateMaze = () => generateMaze(this)\n\n  // Drag and Drop Start and End Nodes\n\n  dragStart = (e) => {\n    const target = e.target\n\n    e.dataTransfer.setData(\"pointID\", target.id)\n\n    setTimeout(() => {\n        target.style.display = \"none\"\n    }, 0)\n\n    setTimeout(() => {\n        target.style.display = \"block\"\n    }, 0)\n\n    this.setState({mouseIsDown: true})\n  }\n\n  drop = (e) => {\n    e.preventDefault()\n\n    this.clearVisited()\n\n    const pointID = e.dataTransfer.getData(\"pointID\")\n\n    const point = document.getElementById(pointID)\n\n    console.log(point)\n\n    point.style.display = \"block\"\n\n    const loc = e.target.id.split(\" \")\n    const row = loc[0]\n    const col = loc[1]\n\n    let pointRow = 0\n    let pointCol = 0\n\n    let pointValue = 0\n    if(pointID === \"start-point\")\n      pointValue = START\n    else if(pointID === \"end-point\")\n      pointValue = END\n\n    for(let i = 0; i < this.state.grid.length; i++){\n      for(let j = 0; j < this.state.grid[0].length; j++){\n        if(this.state.grid[i][j] === pointValue) {\n          pointRow = i\n          pointCol = j\n        }\n      }\n    }\n\n    // Set previous start to nothing \n    // Set new position to start\n\n    this.setState((prevState) => {\n      const newGrid = prevState.grid.map((row) => row.slice())\n\n      newGrid[pointRow][pointCol] = EMPTY\n      newGrid[row][col] = pointValue\n\n      return {\n        grid: newGrid,\n        mouseIsDown: false\n      }\n    })\n\n}\n\n  componentDidMount = () => {\n    window.addEventListener('mousedown', this.handleMouseDown)\n    window.addEventListener('mouseup', this.handleMouseUp)\n  }\n\n  render() {\n    return (\n      <div className=\"app\">\n        <ControlBar \n          rowInput={this.state.rowInput}\n          colInput={this.state.colInput}\n          handleFormButton={this.handleFormButton}\n          handleFormChange={this.handleFormChange}\n          algorithm={this.state.algorithm}\n          marker={this.state.marker}\n          visualize={this.visualize}\n          generateMaze={this.generateMaze}\n        />\n        <Board \n          grid={this.state.grid} \n          numCols={this.state.numCols} \n          numRows={this.state.numRows}\n          marker={this.state.marker}\n          speed={this.state.speed}\n          handleNodeClick={this.handleNodeClick}\n          handleMouseEnter={this.handleMouseEnter}\n          updateGrid={this.updateGrid}\n          mazeIsGenerating={this.state.mazeIsGenerating}\n          drop={this.drop}\n          dragStart={this.dragStart}\n        />\n      </div>\n    )\n  }\n}\n\nexport default App;\n","import { START, END, WALL, VISITED, EMPTY, PATH } from '../Constants/constants'\n\nexport const createGrid = (numRows, numCols) => {\n    const initGrid = []\n\n    for(let i = 0; i < numRows; i++){\n      const row = []\n      for(let j = 0; j < numCols; j++){\n        row.push(0)\n      }\n      initGrid.push(row)\n    }\n\n    const offset = Math.round(numCols / 4);\n    \n    let row = Math.round(numRows / 2) - 1\n    if(row % 2 == 0) row++\n\n    let startCol = offset\n    if(startCol % 2 == 0 && startCol < numCols - 1) startCol++\n    \n    let endCol = numCols - 1 - offset\n    if(endCol % 2 == 0 && endCol < numCols - 1) endCol++\n\n    /*initGrid[Math.round(numRows / 2)-1][offset] = START\n    initGrid[Math.round(numRows / 2)-1][numCols - 1 - offset] = END*/\n\n    initGrid[row][startCol] = START\n    initGrid[row][endCol] = END\n\n    return initGrid\n  }\n\n  export const clearVisited = (app) => {\n\n    app.setState((prevState) => {\n      const newGrid = prevState.grid.map((row) => row.map((element) => (element === VISITED || element === PATH) ? EMPTY : element))\n\n      return {\n        grid: newGrid\n      }\n    })\n  }","import { START, END, WALL, VISITED, EMPTY } from '../Constants/constants'\n\nexport const visualize = (app) => {\n    //console.log(\"visualize\")\n\n    // Find Start Position (n^2) LOL\n    let startRow = 0\n    let startCol = 0\n\n    for(let i = 0; i < app.state.numRows; i++){\n      for(let j = 0; j < app.state.numCols; j++){\n        if(app.state.grid[i][j] === START){\n          startRow = i;\n          startCol = j;\n        }\n      }\n    }\n\n    // Find End Position\n\n    let endRow = 0\n    let endCol = 0\n\n    for(let i = 0; i < app.state.numRows; i++){\n      for(let j = 0; j < app.state.numCols; j++){\n        if(app.state.grid[i][j] === END){\n          endRow = i;\n          endCol = j;\n        }\n      }\n    }\n\n    const visited = []\n\n    for(let i = 0; i < app.state.numRows; i++){\n      const row = []\n      for(let j = 0; j < app.state.numCols; j++){\n        row.push(false)\n      }\n      visited.push(row)\n    }\n\n    app.clearVisited()\n\n    if(app.state.algorithm === \"dfs\"){\n      app.dfs(startRow, startCol, endRow, endCol, visited)\n      //console.log(\"dfs done\")\n    }\n    else if(app.state.algorithm === \"bfs\" || app.state.algorithm === \"dijkstra\")\n      app.bfs(startRow, startCol, endRow, endCol, visited)\n    else if(app.state.algorithm === \"bds\")\n      app.bidirectional(startRow, startCol, endRow, endCol, visited)\n  }\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}